{"version":3,"sources":["webpack:///./src/lib/simplify.js","webpack:///./src/appState.js","webpack:///./src/lib/createSVGContext.js","webpack:///./src/lib/createHeightMapRenderer.js","webpack:///./src/config.js","webpack:///./src/lib/indexPolygon.js","webpack:///./src/getRegionElevation.js","webpack:///./src/main.js"],"names":["getSqSegDist","p","p1","p2","x","y","dx","dy","t","simplifyDouglasPeucker","points","sqTolerance","last","length","simplified","simplifyDPStep","first","index","maxSqDist","i","sqDist","push","simplify","tolerance","highestQuality","undefined","point","prevPoint","newPoints","len","simplifyRadialDist","module","exports","default","appState","angle","currentState","lineDensity","lineWidth","smoothSteps","mapOpacity","heightScale","oceanLevel","aboutVisible","error","zazzleLink","generatingPreview","settingsOpen","shouldDraw","renderProgress","width","window","innerWidth","height","innerHeight","showThemeDetails","selectedTheme","themes","value","name","backgroundColor","lineBackground","lineColor","r","g","b","a","createSVGContext","allPaths","currentPath","api","serialize","map","join","beginPath","segments","lastCommand","stroke","lineCount","lineTo","prefix","round","moveTo","strokeString","lineWidthString","isEmpty","setStroke","strokeStyle","setLineWidth","customLineWidth","createPath","Math","createHeightMapRenderer","regionInfo","canvas","renderHandle","trueWindowHeight","render","cancel","cancelAnimationFrame","toSVG","message","parse_float_default","parseFloat","style","opacity","ctx","getContext","lineStroke","getColor","lineFill","resHeight","windowHeight","resWidth","rowCount","scale","_regionInfo$getAllHei","getAllHeightData","minHeight","maxHeight","rowWithHighestPoint","iteratorSettings","includeRowIndex","stepSize","start","floor","stop","step","createRegionIterator","heightRange","lastLine","lastRow","columnHeights","Float32Array","svg","row","drawSVGLine","isEven","getHeightAtPoint","fY","renderSVGRows","clearRect","fillStyle","fillRect","renderRows","now","performance","drawPolyLine","elapsed","requestAnimationFrame","getSmoothRange","wasVisible","lastRenderedColumnHeight","isVisible","min","smoothRange","max","closePath","fill","windowSize","result","Number","NEGATIVE_INFINITY","POSITIVE_INFINITY","leftOffset","to","count","sum","j","smoothHeight","color","useHex","hex","hexValue","toString","MAPBOX_TOKEN","require","indexPolygon","nominatimResponse","yes","apiURL","imageCache","map_default","getRegionElevation","progress","doneCallback","_map$transform","transform","tileSize","tileZoom","zoomPower","pow","coveringTiles","minzoom","maxzoom","tileBounds","reduce","bounds","tile","canonical","minX","minY","maxX","maxY","Infinity","widthInTiles","heightInTiles","Error","bearing","se","getBounds","getSouthEast","lat","n","PI","atan","exp","tile2lat","project","document","createElement","total","advanceProgress","heightsHandle","isCancelled","tilesToLoad","request","url","replace","z","getRequestForTile","cachedImage","get","promise_default","resolve","img","Image","onload","onerror","crossOrigin","src","set","loadImage","then","image","drawImage","catch","finally","all","canvasWidth","data","getImageData","windowWidth","allHeights","done","timeQuota","lastY","insideMask","collectHeights","startTime","getHeight","lngLat","pointLocation","lng","xTile","l","lng2tile","xOffset","yTile","log","tan","cos","lat2tile","yOffset","yC","xC","R","G","B","decodeHeight","visibleHeights","completed","MapboxGeocoder","addEventListener","e","ga","exDescription","filename","lineno","exFatal","bind","__webpack_require__","oe","heightMapRenderer","regionBuilder","hideHeights","querySelector","updateMap","heightMapCanvas","display","init","mapboxgl","accessToken","Map","trackResize","container","minZoom","center","zoom","hash","addControl","NavigationControl","showCompass","on","once","getBearing","dragRotate","disable","touchZoomRotate","disableRotation","redraw","exportToSVG"],"mappings":"uCAkBA,SAASA,EAAaC,EAAGC,EAAIC,GAEzB,IAAIC,EAAIF,EAAG,GACPG,EAAIH,EAAG,GACPI,EAAKH,EAAG,GAAKC,EACbG,EAAKJ,EAAG,GAAKE,EAEjB,GAAW,IAAPC,GAAmB,IAAPC,EAAU,CAEtB,IAAIC,IAAMP,EAAE,GAAKG,GAAKE,GAAML,EAAE,GAAKI,GAAKE,IAAOD,EAAKA,EAAKC,EAAKA,GAE1DC,EAAI,GACJJ,EAAID,EAAG,GACPE,EAAIF,EAAG,IAEAK,EAAI,IACXJ,GAAKE,EAAKE,EACVH,GAAKE,EAAKC,GAOlB,OAHAF,EAAKL,EAAE,GAAKG,GAGAE,GAFZC,EAAKN,EAAE,GAAKI,GAEUE,EA8C1B,SAASE,EAAuBC,EAAQC,GACpC,IAAIC,EAAOF,EAAOG,OAAS,EAEvBC,GAAcJ,EAAO,IAIzB,OA5BJ,SAASK,EAAeL,EAAQM,EAAOJ,EAAMD,EAAaG,GAItD,IAHA,IACIG,EADAC,EAAYP,EAGPQ,EAAIH,EAAQ,EAAGG,EAAIP,EAAMO,IAAK,CACnC,IAAIC,EAASpB,EAAaU,EAAOS,GAAIT,EAAOM,GAAQN,EAAOE,IAEvDQ,EAASF,IACTD,EAAQE,EACRD,EAAYE,GAIhBF,EAAYP,IACRM,EAAQD,EAAQ,GAAGD,EAAeL,EAAQM,EAAOC,EAAON,EAAaG,GACzEA,EAAWO,KAAKX,EAAOO,IACnBL,EAAOK,EAAQ,GAAGF,EAAeL,EAAQO,EAAOL,EAAMD,EAAaG,IAS3EC,CAAeL,EAAQ,EAAGE,EAAMD,EAAaG,GAC7CA,EAAWO,KAAKX,EAAOE,IAEhBE,EAIX,SAASQ,EAASZ,EAAQa,EAAWC,GAEjC,GAAId,EAAOG,QAAU,EAAG,OAAOH,EAE/B,IAAIC,OAA4Bc,IAAdF,EAA0BA,EAAYA,EAAY,EAKpE,OAFAb,EAASD,EADTC,EAASc,EAAiBd,EA1D9B,SAA4BA,EAAQC,GAMhC,IAJA,IAEIe,EA1CWxB,EAAIC,EAEfG,EACAC,EAqCAoB,EAAYjB,EAAO,GACnBkB,GAAaD,GAGRR,EAAI,EAAGU,EAAMnB,EAAOG,OAAQM,EAAIU,EAAKV,IAC1CO,EAAQhB,EAAOS,GA7CAhB,EA+CMwB,EA7CrBrB,GAFWJ,EA+CGwB,GA7CN,GAAKvB,EAAG,GAChBI,EAAKL,EAAG,GAAKC,EAAG,GAEbG,EAAKA,EAAKC,EAAKA,EA0CgBI,IAC9BiB,EAAUP,KAAKK,GACfC,EAAYD,GAMpB,OAFIC,IAAcD,GAAOE,EAAUP,KAAKK,GAEjCE,EAyC4BE,CAAmBpB,EAAQC,GACtBA,GAM5CoB,EAAOC,QAAUV,EACjBS,EAAOC,QAAQC,QAAUX,uCCjHzB,IAAMY,GACJC,MAAO,EACPC,aAAc,QACdC,YAAa,GACbC,UAAW,EACXC,YAAa,EACbC,WAAY,IACZC,YAAa,GACbC,WAAY,EACZC,cAAc,EACdC,MAAO,KACPC,WAAY,KACZC,mBAAmB,EACnBC,cAAc,EACdC,YAAY,EACZC,eAAgB,KAChBC,MAAOC,OAAOC,WACdC,OAAQF,OAAOG,YACfC,kBAAkB,EAClBC,cAAe,UACfC,SACEC,MAAO,UACPC,KAAM,UACNC,gBAAiB,UACjBC,eAAgB,UAChBC,UAAW,oBAEXJ,MAAO,OACPC,KAAM,OACNC,gBAAiB,UACjBC,eAAgB,UAChBC,UAAW,YAEXJ,MAAO,OACPC,KAAM,OACNC,gBAAiB,UACjBC,eAAgB,UAChBC,UAAW,YAGbF,iBACEG,EAAG,IAAMC,EAAG,IAAMC,EAAG,IAAMC,EAAG,GAEhCL,gBAEEE,EAAG,IAAMC,EAAG,IAAMC,EAAG,IAAMC,EAAG,GAEhCJ,WACEC,EAAG,GAAIC,EAAG,GAAIC,EAAG,GAAIC,EAAG,IAIbhC,oJChDA,SAASiC,EAAiBjB,EAAOG,GAC9C,IAAIe,KACAC,SAEAC,GACFC,UAWF,WACE,sUAIcrB,EAJd,IAIuBG,EAJvB,2BAMCe,EAASI,IAAI,SAAApE,GAAA,OAAKA,EAAEmE,cAAaE,KAAK,MANvC,kBAXAC,UAsBF,WACEL,EAwBJ,WACE,IAAIM,KACAC,EAAc,KACdC,SAAQvC,SACRwC,EAAY,EAEhB,OACEC,OA0BF,SAAgB3E,EAAGC,GACjByE,GAAa,EACb,IAAIE,EAAyB,MAAhBJ,EAAsB,GAAK,IACxCD,EAAStD,KAAT,GAAiB2D,EAASC,EAAM7E,GAAhC,IAAsC6E,EAAM5E,IAC5CuE,EAAc,KA7BdM,OAmBF,SAAgB9E,EAAGC,GACjB,IAAI2E,EAAyB,MAAhBJ,EAAsB,GAAK,IACxCD,EAAStD,KAAT,GAAiB2D,EAASC,EAAM7E,GAAhC,IAAsC6E,EAAM5E,IAC5CuE,EAAc,KArBdL,UAYF,WACE,IAAIY,EAAeN,aAAoBA,EAApB,KAAiC,GAChDO,EAAgC,IAAd9C,EAAA,iBAAmCA,EAAnC,IAAkD,GACxE,kBAAmBqC,EAASF,KAAK,KAAjC,iBAAsDU,EAAeC,EAArE,YAdAC,QAJK,WAKH,OAAqB,IAAdP,GAETQ,UAPK,SAOKC,GACRV,EAASU,GAEXC,aAVK,SAUQC,GACXnD,EAAYmD,IAzCAC,IAtBdX,OAyBF,SAAgB3E,EAAGC,GACjBgE,EAAYU,OAAO3E,EAAGC,IAzBtB6E,OA4BF,SAAgB9E,EAAGC,GACjBgE,EAAYa,OAAO9E,EAAGC,IA5BtBwE,OA+BF,WACMR,IAAgBA,EAAYgB,YAC1Bf,EAAIiB,aACNlB,EAAYiB,UAAUhB,EAAIiB,aAExBjB,EAAIhC,WACN+B,EAAYmB,aAAalB,EAAIhC,WAE/B8B,EAAS/C,KAAKgD,KAtChB/B,UAAW,EACXiD,YAAa,WAGf,OAAOjB,EAgFT,SAASW,EAAM7E,GACb,OAAOuF,KAAKV,MAAU,IAAJ7E,GAAS,IC1Fd,SAASwF,EAAwB1D,EAAU2D,EAAYC,GACpE,IAAIC,SACAC,SAIJ,OAFAC,KAMEC,OA6NF,WACEC,qBAAqBJ,GACrB7D,EAASe,eAAiB,MA9N1BgD,UAGF,SAASA,EAAOG,GAEVlE,EAASe,iBACXf,EAASe,eAAeoD,QAAU,gBAGpC,IAAM3D,EAAa4D,IAAkBpE,EAASQ,YAE1CH,EAAcgE,WAAWrE,EAASK,aAEtCuD,EAAOU,MAAMC,QAAUvE,EAASM,WAAa,IAE7C,IAAIkE,EAAMZ,EAAOa,WAAW,MACxBC,EAAaC,EAAS3E,EAAS4B,WAC/BgD,EAAWD,EAAS3E,EAAS2B,gBAC7BvB,EAAYgE,IAAkBpE,EAASI,WAEvCyE,EAAYlB,EAAWmB,aACvBC,EAAW9D,OAAOC,WAClB8D,EAAWvB,KAAKV,MAAM8B,EAAY7E,EAASG,YAAc,KACzD8E,EAAQjF,EAASO,YApBA2E,EAwB+BvB,EAAWwB,mBAAxDC,EAxBcF,EAwBdE,UAAWC,EAxBGH,EAwBHG,UAAWC,EAxBRJ,EAwBQI,oBACvBC,EA4OR,SAA8BP,EAAUH,EAAWW,GACjD,IAAIC,EAAWhC,KAAKV,MAAM8B,EAAYG,GAClCU,EAAQF,EAAkB/B,KAAKkC,MAAMH,EAAgBC,GAAYA,EACjEG,EAAOF,EAAQD,EAAWhC,KAAKkC,OAAOd,EAAYa,GAASD,GAE/D,OACEC,QACAE,OACAC,KAAMJ,GApPiBK,CAAqBd,EAAUH,EAAWS,GAI/DS,EAAcV,EAAYD,EAE1BY,KACAC,EAAUV,EAAiBG,MAI3BQ,SAGJ,GAFApC,EAAmB7C,OAAOG,YAEtB8C,EAAO,CAETQ,EAAaC,EAAS3E,EAAS4B,WAA0B,GACzDsE,EAAgB,IAAIC,aAAalF,OAAOC,YACxC+E,EAAUV,EAAiBK,KAI3B,IAAK,IAAI1H,EAAI,EAAGA,EAAI+C,OAAOC,aAAchD,EACvCgI,EAAchI,GAAK4F,EAErB,OAQF,WAME,IAJA,IAAIsC,EAAMnE,EAAiBhB,OAAOC,WAAYD,OAAOG,aACjDiF,EAAM,EACNrF,EAAQC,OAAOC,WAEV/C,EAAI8H,EAAS9H,EAAI,EAAGA,GAAKoH,EAAiBM,KAAM,CACvDS,EAAYN,EAAUI,GACtBJ,KACA,IAAIO,EAAUF,EAAM,GAAO,EAC3BA,GAAO,EAEP,IAAK,IAAIpH,EAAI,EAAGA,EAAI+B,EAAO/B,GAAK,EAAG,CACjC,IAAIf,EAAIqI,EAAStH,EAAI+B,EAAQ,EAAI/B,EAC7BkC,EAASwC,EAAW6C,iBAAiBtI,EAAGC,GACxCsI,EAAKtI,EAAIsF,KAAKkC,MAAMV,GAAS9D,EAASiE,GAAaW,GACnD5E,GAAUX,GACZ8F,EAAYN,EAAUI,GACtBJ,MAEAA,EAAS7G,KAAKjB,EAAGuI,GAIrBR,EAAU9H,EAAIoH,EAAiBM,KAMjC,GAHAS,EAAYN,EAAUI,GAEtBpG,EAASe,eAAiB,KACtBqF,EAAI/D,UAEN,OAAO+D,EAAI/D,YAxCNqE,GAGP,OA6JAlC,EAAIhC,YACJgC,EAAImC,UAAU,EAAG,EAAG5B,EAAUF,GAC9BL,EAAIoC,UAAYjC,EAAS3E,EAAS0B,iBAClC8C,EAAIqC,SAAS,EAAG,EAAG9B,EAAUF,GAnH/B,SAASiC,IACP,IAAIC,EAAMC,YAAYD,MAEtB,IAAK,IAAI5I,EAAI8H,EAAS9H,GAAKoH,EAAiBK,KAAMzH,GAAKoH,EAAiBM,KAAM,CAC5EoB,EAAajB,GACbA,KAEA,IAAK,IAAI9H,EAAI,EAAGA,EAAI+C,OAAOC,aAAchD,EAAG,CAC1C,IAAIiD,EAASwC,EAAW6C,iBAAiBtI,EAAGC,GACxCsI,EAAKtI,EAAIsF,KAAKkC,MAAMV,GAAS9D,EAASiE,GAAaW,GAEnD5E,GAAUX,GACZyG,EAAajB,GACbA,MAEAA,EAAS7G,KAAKjB,EAAGuI,GAIrBR,EAAU9H,EAAIoH,EAAiBM,KAC/B,IAAIqB,EAAUF,YAAYD,MAAQA,EAClC,GAAIG,EAAU,IAEZ,YADArD,EAAesD,sBAAsBL,IAKzCG,EAAajB,GAEbhG,EAASe,eAAiB,KA1EnB+F,GAmFT,SAASR,EAAY9H,EAAQ4H,GAC3B,KAAI5H,EAAOG,OAAS,GAApB,CAGAH,EADkB4I,EAAe5I,EAAQ6B,GACpB7B,OAErB4H,EAAI5D,YACJ4D,EAAI/C,YAAcqB,EAClB0B,EAAIhG,UAAYA,EAEhB,IADA,IAAIiH,GAAa,EACRpI,EAAI,EAAGA,EAAIT,EAAOG,OAAQM,GAAK,EAAG,CACzC,IAAIf,EAAIM,EAAOS,GACXd,EAAIK,EAAOS,EAAI,GAEfqI,EAA2BpB,EAAchI,GACzCqJ,EAAYpJ,GAAKmJ,GAA4BnJ,GAAK,GAAKA,EAAI2F,EAC3DyD,GAGFrB,EAAchI,GAAKuF,KAAK+D,IAAIrJ,EAAGmJ,GAE3BD,EACFjB,EAAIvD,OAAO3E,EAAGC,GAEdiI,EAAIpD,OAAO9E,EAAGC,IAIZkJ,EAEFjB,EAAIvD,OAAO3E,EAAGC,EAAI,EAAI,EAAImJ,GAE1BlB,EAAIpD,OAAO9E,EAAGC,EAAI,EAAG,EAAImJ,GAG7BD,EAAaE,EAEfnB,EAAIzD,UAMN,SAASsE,EAAazI,GACpB,KAAIA,EAAOG,OAAS,GAApB,CAEA,IAAI8I,EAAcL,EAAe5I,EAAQ6B,GAIzC,GAHA7B,EAASiJ,EAAYjJ,OAGjBiJ,EAAYC,IAAMD,EAAYD,IAAM,EAAG,CACzChD,EAAIhC,YACJgC,EAAIoC,UAAYhC,EAChBJ,EAAIxB,OAAOxE,EAAO,GAAIA,EAAO,IAC7B,IAAK,IAAIS,EAAI,EAAGA,EAAIT,EAAOG,OAAQM,GAAK,EACtCuF,EAAI3B,OAAOrE,EAAOS,GAAIT,EAAOS,EAAI,IAEnCuF,EAAI3B,OAAOrE,EAAOA,EAAOG,OAAS,GAAI8I,EAAYC,KAClDlD,EAAI3B,OAAOrE,EAAO,GAAIiJ,EAAYC,KAClClD,EAAImD,YACJnD,EAAIoD,OAGNpD,EAAIhC,YACJgC,EAAInB,YAAcqB,EAClBF,EAAIpE,UAAYA,EAChBoE,EAAIxB,OAAOxE,EAAO,GAAIA,EAAO,IAC7B,IAAK,IAAIS,EAAI,EAAGA,EAAIT,EAAOG,OAAQM,GAAK,EACtCuF,EAAI3B,OAAOrE,EAAOS,GAAIT,EAAOS,EAAI,IAEnCuF,EAAI7B,WAoBR,SAASyE,EAAe5I,EAAQqJ,GAK9B,IAJA,IAAIC,KACAJ,EAAMK,OAAOC,kBACbR,EAAMO,OAAOE,kBACbtJ,EAASH,EAAOG,OAAS,EACpBM,EAAI,EAAGA,EAAIN,EAAQM,GAAK,EAAG,CAOlC,IANA,IAAMiJ,EAAajJ,EAAI4I,EAEjBM,EAAKlJ,EAAI4I,EAAa,EAExBO,EAAQ,EACRC,EAAM,EACDC,EALIJ,GAAc,EAAIA,EAAa,EAKzBI,EAAIH,GAAMG,EAAI3J,EAAQ2J,GAAK,EAC5CD,GAAO7J,EAAO,EAAI8J,EAAI,GACtBF,GAAS,EAGX,IAAIG,EAAeF,EAAMD,EACzBN,EAAO,EAAI7I,GAAKT,EAAO,EAAIS,GAC3B6I,EAAO,EAAI7I,EAAI,GAAKsJ,EAEhBb,EAAMa,IAAcb,EAAMa,GAC1Bf,EAAMe,IAAcf,EAAMe,GAGhC,OACE/J,OAAQsJ,EACRN,MACAE,OAmBJ,SAAS/C,EAAS6D,EAAOC,GACvB,OAAIA,EACF,IAAWC,EAAIF,EAAM3G,GAAK6G,EAAIF,EAAM1G,GAAK4G,EAAIF,EAAMzG,GAErD,QAAeyG,EAAM3G,EAArB,KAA2B2G,EAAM1G,EAAjC,KAAuC0G,EAAMzG,EAA7C,KAAmDyG,EAAMxG,EAAzD,KAIJ,SAAS0G,EAAIxK,GACX,GAAU,IAANA,EAAS,MAAO,KACpB,IAAIyK,EAAWzK,EAAE0K,SAAS,IAC1B,OAAO1K,EAAI,GAAK,IAAMyK,EAAWA,ECnT5B,IAAME,EAAe,qICAfC,EAAQ,QACNA,EAAQ,QAGR,SAASC,EAAaC,GACnC,OAAOC,EAgBP,SAASA,IAAQ,OAAO,GClB1B,IAAMC,yFAAgGL,EAClGM,EAAa,IAAIC,EAAApH,EAEN,SAASqH,EAAmB/G,EAAKgH,EAAUC,GACnDD,IAAUA,MADuD,IAAAE,EAGzClH,EAAImH,UAA1BC,EAH+DF,EAG/DE,SAAUC,EAHqDH,EAGrDG,SACXC,EAAYnG,KAAKoG,IAAI,EAAGF,GAExBG,EAAgBxH,EAAImH,UAAUK,eAClCC,QAASJ,EACTK,QAASL,EACTD,aAGIO,EAA4BH,EAiOrBI,OAAO,SAACC,EAAQC,GAC3B,IAAIrM,EAAIqM,EAAKC,UAMb,OALIF,EAAOG,KAAOvM,EAAEG,IAAGiM,EAAOG,KAAOvM,EAAEG,GACnCiM,EAAOI,KAAOxM,EAAEI,IAAGgM,EAAOI,KAAOxM,EAAEI,GACnCgM,EAAOK,KAAOzM,EAAEG,IAAGiM,EAAOK,KAAOzM,EAAEG,GACnCiM,EAAOM,KAAO1M,EAAEI,IAAGgM,EAAOM,KAAO1M,EAAEI,GAEhCgM,IAEPG,KAAMI,IACNH,KAAMG,IACNF,MAAM,IACNC,MAAM,MA5OFE,EAAeV,EAAWO,KAAOP,EAAWK,KAC5CM,EAAgBX,EAAWQ,KAAOR,EAAWM,KACnD,GAAII,EAAe,IAAMC,EAAgB,GAAI,MAAM,IAAIC,MAAM,gDAC7D,IAAI/F,EAAe7D,OAAOG,YAE1B,IAAKkB,EAAImH,UAAUxJ,QAAUqC,EAAImH,UAAUqB,QAAS,CAElD,IAAIC,EAAKzI,EAAI0I,YAAYC,eACzBF,EAAGG,IAgMP,SAAkB/M,EAAGyL,GACnB,IAAIuB,EAAI1H,KAAK2H,GAAK,EAAI3H,KAAK2H,GAAKjN,EAAIyL,EACpC,OAAO,IAAMnG,KAAK2H,GAAK3H,KAAK4H,KAAK,IAAK5H,KAAK6H,IAAIH,GAAG1H,KAAK6H,KAAKH,KAlMjDI,CAAStB,EAAWQ,KAAO,EAAGb,GACvC9E,EAAexC,EAAIkJ,QAAQT,GAAI5M,EAGjC,IAAMyF,EAAS6H,SAASC,cAAc,UACtC9H,EAAO5C,OAAS2J,EAAe,GAAKjB,EACpC9F,EAAOzC,QAAUyJ,EAAgB,GAAKlB,EAEtC,IAAMlF,EAAMZ,EAAOa,WAAW,MAExB6F,EAAOL,EAAWK,KAClBC,EAAON,EAAWM,KAExBjB,EAASqC,MAAQ7B,EAAcnL,OAE/BiN,IAEA,IAAIC,SACAC,GAAc,EACZC,EAAcjC,EAAcxH,IAoHlC,SAAsB8H,GACpB,IAAM4B,EAkBR,SAA2B5B,GACzB,IAAMrM,EAAIqM,EAAKC,UAMf,OACE4B,IANU/C,EACTgD,QAAQ,OAAQnO,EAAEoO,GAClBD,QAAQ,OAAQnO,EAAEI,GAClB+N,QAAQ,QAASnO,EAAEG,GAIpBA,EAAGwL,GAAY3L,EAAEG,EAAI+L,EAAWK,MAChCnM,EAAGuL,GAAY3L,EAAEI,EAAI8L,EAAWM,OA5BlB6B,CAAkBhC,GAElC,OA2DJ,SAAmB6B,GACjB,IAAII,EAAclD,EAAWmD,IAAIL,GAC5BI,IACHA,EAAc,IAAIE,EAAAvK,EAAQ,SAACwK,EAAS9L,GAClC,IAAM+L,EAAM,IAAIC,MAChBD,EAAIE,OAAS,WACXH,EAAQC,IAEVA,EAAIG,QAAUlM,EACd+L,EAAII,YAAc,YAClBJ,EAAIK,IAAMb,IAEZ9C,EAAW4D,IAAId,EAAKI,IAGtB,OAAOA,EA1EEW,CAAUhB,EAAQC,KACtBgB,KAIH,SAAuBC,GACrB1I,EAAI2I,UAAUD,EAAOlB,EAAQ9N,EAAG8N,EAAQ7N,KAJvCiP,MAOH,WACE5I,EAAIhC,YACJgC,EAAIoC,UAAY,UAChBpC,EAAIqC,SAASmF,EAAQ9N,EAAG8N,EAAQ7N,EAAGuL,EAAUA,KAT5C2D,QAAQzB,KA/Gb,OATAW,EAAAvK,EAAQsL,IAAIvB,GACTkB,KAgCH,WACE,IAAMM,EAAc3J,EAAO5C,MACrBwM,EAAOhJ,EAAIiJ,aAAa,EAAG,EAAGF,EAAa3J,EAAOzC,QAAQqM,KAC1DE,EAAczM,OAAOC,WACvByM,EAAa,IAAIxH,aAAauH,EAAc5I,GAC5C8I,SAEAC,EAAY,GACZzI,EAAYsF,IACZrF,GAAaqF,IACbpF,GAAuB,EACvBwI,EAAQ,EAIRC,EAAahF,IAGjB,OAFA8C,EAAgB1E,sBAIhB,SAAS6G,IAGP,IAFA,IAAIC,EAAYhN,OAAO+F,YAAYD,MAE1B5I,EAAI2P,EAAO3P,EAAI2G,IAAgB3G,EAAG,CACzC,IAAK,IAAID,EAAI,EAAGA,EAAIwP,IAAexP,EAAG,CACpC,IAAMa,EAAQZ,EAAIuP,EAAcxP,EAC1BiD,EAAS+M,EAAUhQ,EAAGC,EAAG4P,GAC/BJ,EAAW5O,GAASoC,EAChBA,EAASiE,IAAWA,EAAYjE,GAChCA,EAASkE,IACXA,EAAYlE,EACZmE,EAAsBnH,GAG1B,IAAI+I,EAAUjG,OAAO+F,YAAYD,MAAQkH,EACzC,GAAI/G,EAAU2G,EAEZ,YADK/B,IAAaD,EAAgB1E,sBAAsB6G,KAG1DF,EAAQ3P,EAGVyP,GACExI,YAAWC,YACXC,sBACAqI,aACAD,cACA5I,mBA7BG,IAAIyH,EAAAvK,EAAQ,SAACwK,GAAcoB,EAAOpB,IAiCzC,SAAS0B,EAAUhQ,EAAGC,EAAG4P,GACvB,IAAII,EAAS7L,EAAImH,UAAU2E,eAAelQ,IAAGC,MAC7C,IAAK4P,GAAYI,EAAOE,IAAKF,EAAOjD,MAAO,OAAQ,GAEnD,IAAIoD,EAqEV,SAAkBC,EAAG3E,GAEnB,OADe2E,EAAI,KAAO,IAAO3E,EAtEjB4E,CAASL,EAAOE,IAAKzE,GAC7B6E,GAAWH,EAAQhE,GAAQZ,EAC3BgF,EAwEV,SAAkBH,EAAG3E,GACnB,IAAI3J,EAAQsO,EAAI9K,KAAK2H,GAAK,IAC1B,OACI,EAAI3H,KAAKkL,IAAKlL,KAAKmL,IAAI3O,GAAS,EAAIwD,KAAKoL,IAAI5O,IAC3CwD,KAAK2H,IACP,EAAKxB,EA7EOkF,CAASX,EAAOjD,IAAKtB,GAC7BmF,GAAWL,EAAQnE,GAAQb,EAC3BsF,EAAKvL,KAAKV,MAAMgM,GAChBE,EAAKxL,KAAKV,MAAM0L,GAEhB1P,EAAkC,GAAzBiQ,EAAKzB,EAAc0B,GAC5BC,EAAI1B,EAAKzO,EAAQ,GACjBoQ,EAAI3B,EAAKzO,EAAQ,GACjBqQ,EAAI5B,EAAKzO,EAAQ,GAErB,OAGF,SAAsBmQ,EAAGC,EAAGC,GAC1B,IAAIjO,EAAmD,IAA3B,IAAJ+N,EAAU,IAAU,IAAJC,EAAUC,GAApC,IACVjO,GAAU,MAGZA,GAAkB,KAEpB,OAAOA,EAVAkO,CAAaH,EAAGC,EAAGC,MAlG3BnC,KAcH,SAAmBqC,GACjB,IAAItO,EAAQsO,EAAe5B,YACvBC,EAAa2B,EAAe3B,WAEhC,OACEnH,iBAOF,SAA0BtI,EAAGC,GAC3B,OAAOwP,EAAWzP,EAAIC,EAAI6C,IAP1B8D,eACAK,iBAHK,WAIH,OAAOmK,MArBVrC,KAAK,SAAA7K,GACC0J,GACHvC,EAAanH,MAKjB4B,OADK,WAEH8H,GAAc,EACd7H,qBAAqB4H,KAuIzB,SAASD,SACoBrM,IAAvB+J,EAASiG,YACXjG,EAASiG,WAAa,GAExBjG,EAASiG,UAAY9L,KAAK+D,IAAI8B,EAASqC,MAAOrC,EAASiG,UAAY,GACnEjG,EAASnF,QAAT,sBAAyCmF,EAASiG,UAAlD,OAAkEjG,EAASqC,MAA3E,OC/LJ,IAAI6D,EAAiB1G,EAAQ,QAC7B7H,OAAOwO,iBAAiB,QAoGxB,SAAkBC,GAChB,GAAkB,mBAAPC,GAAmB,OAE9B,IAAMC,EAAgBF,EAAOA,EAAEvL,QAAT,OAAuBuL,EAAEG,SAAzB,IAAqCH,EAAEI,OAAW,oBAExEH,GAAG,OAAQ,aACTC,gBACAG,SAAS,MAxGbjH,uBACEA,EAAQ,SADVkH,KAAA,KAAAC,IAAA7C,MAAA6C,EAAAC,IAKA,IAAI5N,OAAGA,EACH6N,SACAC,SAsCJ,SAASC,IACPrQ,IAASW,WAAa,KACtB,IAAIiD,EAAS6H,SAAS6E,cAAc,eAChC1M,IAAQA,EAAOU,MAAMC,QAAU,KAcrC,SAASgM,IACP,GAAKjO,EAAL,CAEA,IAAIkO,EAAkB/E,SAAS6E,cAAc,eACxCE,IAEDL,GACFA,EAAkBnM,SAEhBoM,GACFA,EAAcpM,SAGXhE,IAASc,YAIZ0P,EAAgBlM,MAAMmM,QAAU,GAGlCzQ,IAASe,gBACPoD,QAAS,GACT2H,aAAa,EACbyD,WAAW,GAIba,EAAgB/G,EAAmB/G,EAAKtC,IAASe,eAEjD,SAA2B4C,GACzBwM,EAAoBzM,EAAwB1D,IAAU2D,EAAY6M,MAhBlEA,EAAgBlM,MAAMmM,QAAU,SAnEpCzQ,IAAS0Q,KAKT,WACEC,IAASC,YAAc/H,EAEvB5H,OAAOqB,IAAMA,EAAM,IAAIqO,IAASE,KAC9BC,aAAa,EACbC,UAAW,MACXC,QAAS,EACT1M,MAAO,mCACP2M,SAAU,QAAS,QACnBC,KAAM,KACNC,MAAM,IAGR7O,EAAI8O,WACF,IAAIT,IAASU,mBAAoBC,aAAa,IAC9C,gBAEFhP,EAAI8O,WAAW,IAAI5B,GAAiBoB,YAAaD,IAASC,eAC1DtO,EAAIiP,GAAG,UAAW,WAChBjP,EAAIkP,KAAK,OAAQjB,KAEnBjO,EAAIiP,GAAG,YAAalB,GACpB/N,EAAIiP,GAAG,OAAQ,WACbvR,IAASC,MAAQqC,EAAImP,eAIvBnP,EAAIoP,WAAWC,UACfrP,EAAIsP,gBAAgBC,mBAhCtB7R,IAAS8R,OAyCT,WACE,IAAK3B,EAAmB,OACxBA,EAAkBnM,SAClBmM,EAAkBpM,UA3CpB/D,IAASuQ,UAAYA,EACrBvQ,IAAS+R,YA6CT,WACE,IAAK5B,EAAmB,OACxB,OAAOA,EAAkBpM,QAAO","file":"static/js/app.64765544114b0373f494.js","sourcesContent":["/*\n (c) 2017, Vladimir Agafonkin\n Simplify.js, a high-performance JS polyline simplification library\n mourner.github.io/simplify-js\n\n (c) 2020, Andrei Kashcha - replaced .x and .y as recommended in original code\n*/\n\n// square distance between 2 points\nfunction getSqDist(p1, p2) {\n\n    var dx = p1[0] - p2[0],\n        dy = p1[1] - p2[1];\n\n    return dx * dx + dy * dy;\n}\n\n// square distance from a point to a segment\nfunction getSqSegDist(p, p1, p2) {\n\n    var x = p1[0],\n        y = p1[1],\n        dx = p2[0] - x,\n        dy = p2[1] - y;\n\n    if (dx !== 0 || dy !== 0) {\n\n        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);\n\n        if (t > 1) {\n            x = p2[0];\n            y = p2[1];\n\n        } else if (t > 0) {\n            x += dx * t;\n            y += dy * t;\n        }\n    }\n\n    dx = p[0] - x;\n    dy = p[1] - y;\n\n    return dx * dx + dy * dy;\n}\n// rest of the code doesn't care about point format\n\n// basic distance-based simplification\nfunction simplifyRadialDist(points, sqTolerance) {\n\n    var prevPoint = points[0],\n        newPoints = [prevPoint],\n        point;\n\n    for (var i = 1, len = points.length; i < len; i++) {\n        point = points[i];\n\n        if (getSqDist(point, prevPoint) > sqTolerance) {\n            newPoints.push(point);\n            prevPoint = point;\n        }\n    }\n\n    if (prevPoint !== point) newPoints.push(point);\n\n    return newPoints;\n}\n\nfunction simplifyDPStep(points, first, last, sqTolerance, simplified) {\n    var maxSqDist = sqTolerance,\n        index;\n\n    for (var i = first + 1; i < last; i++) {\n        var sqDist = getSqSegDist(points[i], points[first], points[last]);\n\n        if (sqDist > maxSqDist) {\n            index = i;\n            maxSqDist = sqDist;\n        }\n    }\n\n    if (maxSqDist > sqTolerance) {\n        if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);\n        simplified.push(points[index]);\n        if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);\n    }\n}\n\n// simplification using Ramer-Douglas-Peucker algorithm\nfunction simplifyDouglasPeucker(points, sqTolerance) {\n    var last = points.length - 1;\n\n    var simplified = [points[0]];\n    simplifyDPStep(points, 0, last, sqTolerance, simplified);\n    simplified.push(points[last]);\n\n    return simplified;\n}\n\n// both algorithms combined for awesome performance\nfunction simplify(points, tolerance, highestQuality) {\n\n    if (points.length <= 2) return points;\n\n    var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;\n\n    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);\n    points = simplifyDouglasPeucker(points, sqTolerance);\n\n    return points;\n}\n\n// export as AMD module / Node module / browser or worker variable\nmodule.exports = simplify;\nmodule.exports.default = simplify;\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/simplify.js","const appState = {\n  angle: 0,\n  currentState: 'intro',\n  lineDensity: 28,\n  lineWidth: 1,\n  smoothSteps: 1,\n  mapOpacity: 100,\n  heightScale: 42,\n  oceanLevel: 0,\n  aboutVisible: false,\n  error: null,\n  zazzleLink: null,\n  generatingPreview: false,\n  settingsOpen: false,\n  shouldDraw: false,\n  renderProgress: null,\n  width: window.innerWidth,\n  height: window.innerHeight,\n  showThemeDetails: false,\n  selectedTheme: 'default',\n  themes: [{\n    value: 'default',\n    name: 'default',\n    backgroundColor: '#F7F2E8',\n    lineBackground: '#F7F2E8',\n    lineColor: 'rgb(22, 22, 22)'\n  }, {\n    value: 'dark', \n    name: 'dark',\n    backgroundColor: '#3C3D3D',\n    lineBackground: '#3C3D3D',\n    lineColor: '#ffffff'\n  }, {\n    value: 'blue',\n    name: 'blue',\n    backgroundColor: '#101E33',\n    lineBackground: '#101E33',\n    lineColor: '#D1D8E3'\n  }],\n\n  backgroundColor: {\n    r: 0xF7, g: 0xF2, b: 0xE8, a: 1\n  },\n  lineBackground: {\n    // r: 255, g: 255, b: 255, a: 1\n    r: 0xF7, g: 0xF2, b: 0xE8, a: 1\n  },\n  lineColor: {\n    r: 22, g: 22, b: 22, a: 1.0\n  },\n};\n\nexport default appState;\n\n\n// WEBPACK FOOTER //\n// ./src/appState.js","/**\n * Basic proxy that acts like a 2d canvas context and renders paths\n * to SVG string. Supports limited subset of operations.\n */\nexport default function createSVGContext(width, height) {\n  let allPaths = [];\n  let currentPath;\n\n  let api = {\n    serialize,\n    beginPath,\n    lineTo,\n    moveTo,\n    stroke,\n    lineWidth: 1,\n    strokeStyle: '#161616'\n  }\n\n  return api;\n\n  function serialize() {\n    return `<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!-- Generator: https://github.com/anvaka/peak-map  -->\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n   viewBox=\"0 0 ${width} ${height}\">\n<g id='paths'>\n   ${allPaths.map(x => x.serialize()).join('\\n')}\n</g>\n</svg>`\n  }\n\n  function beginPath() {\n    currentPath = createPath();\n  }\n\n  function lineTo(x, y) {\n    currentPath.lineTo(x, y);\n  }\n\n  function moveTo(x, y) {\n    currentPath.moveTo(x, y);\n  }\n\n  function stroke() {\n    if (currentPath && !currentPath.isEmpty()) {\n      if (api.strokeStyle) {\n        currentPath.setStroke(api.strokeStyle);\n      }\n      if (api.lineWidth) {\n        currentPath.setLineWidth(api.lineWidth);\n      }\n      allPaths.push(currentPath);\n    }\n  }\n}\n\nfunction createPath() {\n  let segments = [];\n  let lastCommand = null;\n  let stroke, lineWidth;\n  let lineCount = 0;\n\n  return {\n    lineTo,\n    moveTo,\n    serialize,\n    isEmpty() {\n      return lineCount === 0;\n    },\n    setStroke(strokeStyle) {\n      stroke = strokeStyle;\n    },\n    setLineWidth(customLineWidth) {\n      lineWidth = customLineWidth;\n    },\n  }\n\n  function serialize() {\n    let strokeString = stroke ? `stroke=\"${stroke}\" ` : '';\n    let lineWidthString = lineWidth !== 1 ? `stroke-width=\"${lineWidth}\"` : '';\n    return `<path d=\"${segments.join(' ')}\" fill=\"none\" ${strokeString}${lineWidthString}></path>`\n  }\n\n  function moveTo(x, y) {\n    let prefix = lastCommand === 'M' ? '' : 'M';\n    segments.push(`${prefix}${round(x)} ${round(y)}`)\n    lastCommand = 'M';\n  }\n\n  function lineTo(x, y) {\n    lineCount += 1;\n    let prefix = lastCommand === 'L' ? '' : 'L';\n    segments.push(`${prefix}${round(x)} ${round(y)}`)\n    lastCommand = 'L';\n  }\n}\n\nfunction round(x) {\n  return Math.round(x * 100)/100\n}\n\n\n// WEBPACK FOOTER //\n// ./src/lib/createSVGContext.js","import createSVGContext from './createSVGContext';\n\n/**\n * This is the core component of the website which renders lines on the overlay\n * layer\n * @param {*} appState - @see ../appState.js\n * @param {*} map  - mapbox map instance\n * @param {*} canvas  - where the lines should be rendered\n */\nexport default function createHeightMapRenderer(appState, regionInfo, canvas) {\n  let renderHandle;\n  let trueWindowHeight;\n\n  render();\n\n  return {\n    /**\n     * When new render request is created, we have to cancel the current one:\n     */\n    cancel,\n    render\n  }\n\n  function render(toSVG) {\n    // let's set everything up to match our application state:\n    if (appState.renderProgress) {\n      appState.renderProgress.message = 'Rendering...'\n    }\n\n    const oceanLevel = Number.parseFloat(appState.oceanLevel);\n\n    let smoothSteps = parseFloat(appState.smoothSteps);\n\n    canvas.style.opacity = appState.mapOpacity / 100;\n\n    let ctx = canvas.getContext('2d');\n    let lineStroke = getColor(appState.lineColor);\n    let lineFill = getColor(appState.lineBackground);\n    let lineWidth = Number.parseFloat(appState.lineWidth);\n\n    let resHeight = regionInfo.windowHeight;\n    let resWidth = window.innerWidth;\n    let rowCount = Math.round(resHeight * appState.lineDensity / 100); \n    let scale = appState.heightScale;\n\n    // since tiles can be partially overlapped, we use our own iterator\n    // over partially overlapped tiles (to not deal with offset math here)\n    const {minHeight, maxHeight, rowWithHighestPoint} = regionInfo.getAllHeightData();\n    const iteratorSettings = createRegionIterator(rowCount, resHeight, rowWithHighestPoint);\n\n    // we want the scale be independent from the zoom level, use the distribution\n    // of heights as our scaler:\n    let heightRange = maxHeight - minHeight;\n\n    let lastLine = [];\n    let lastRow = iteratorSettings.start;\n\n    // When rendered to SVG - count the filled area, so that we can break paths\n    // if they overlap already rendered paths\n    let columnHeights;\n    trueWindowHeight = window.innerHeight;\n\n    if (toSVG) {\n      // SVG needs hex values, not rgba, also ignore alpha\n      lineStroke = getColor(appState.lineColor, /* useHex = */ true);\n      columnHeights = new Float32Array(window.innerWidth);\n      lastRow = iteratorSettings.stop;\n      // This is going to be our look up structure. Point `(x, y)` is visible\n      // only if its `y` coordinate is smaller than `columnHeight[x]` value.\n      // (we render from bottom to top for svg files)\n      for (let x = 0; x < window.innerWidth; ++x) {\n        columnHeights[x] = trueWindowHeight; \n      }\n      return renderSVGRows();\n    } else {\n      clearScene();\n      return renderRows();\n    }\n\n    // Public part is over. Below is is just implementation detail\n\n    function renderSVGRows() {\n\n      let svg = createSVGContext(window.innerWidth, window.innerHeight); // || ctx - they both work here.\n      let row = 0;\n      let width = window.innerWidth;\n\n      for (let y = lastRow; y > 0; y -= iteratorSettings.step) {\n        drawSVGLine(lastLine, svg);\n        lastLine = [];\n        let isEven = (row % 2) === 0\n        row += 1;\n\n        for (let i = 0; i < width; i += 1) {\n          let x = isEven ? i : width - 1 - i;\n          let height = regionInfo.getHeightAtPoint(x, y);\n          let fY = y - Math.floor(scale * (height - minHeight) / heightRange);\n          if (height <= oceanLevel) {\n            drawSVGLine(lastLine, svg);\n            lastLine = [];\n          } else {\n            lastLine.push(x, fY);\n          }\n        }\n\n        lastRow = y - iteratorSettings.step;\n      }\n\n      drawSVGLine(lastLine, svg);\n\n      appState.renderProgress = null;\n      if (svg.serialize) {\n        // ctx (used for debugging) doesn't have this method\n        return svg.serialize();\n      }\n    }\n\n    /**\n     * This renders rows, and stops if allowed time quota is exceeded (making rendering\n     * async, so that we do not freeze the main thread)\n     */\n    function renderRows() {\n      let now = performance.now();\n\n      for (let y = lastRow; y <= iteratorSettings.stop; y += iteratorSettings.step) {\n        drawPolyLine(lastLine, true);\n        lastLine = [];\n\n        for (let x = 0; x < window.innerWidth; ++x) {\n          let height = regionInfo.getHeightAtPoint(x, y);\n          let fY = y - Math.floor(scale * (height - minHeight) / heightRange);\n\n          if (height <= oceanLevel) {\n            drawPolyLine(lastLine, true);\n            lastLine = [];\n          } else {\n            lastLine.push(x, fY);\n          }\n        }\n\n        lastRow = y + iteratorSettings.step;\n        let elapsed = performance.now() - now;\n        if (elapsed > 200) {\n          renderHandle = requestAnimationFrame(renderRows);\n          return;\n        }\n      }\n\n      drawPolyLine(lastLine, true);\n\n      appState.renderProgress = null;\n    }\n\n    /**\n     * Draws a polyline, that does not intersect already rendered\n     * lines. Assumption is that we render from bottom to the top.\n     * \n     * \n     */\n    function drawSVGLine(points, svg) {\n      if (points.length < 3) return;\n\n      let smoothRange = getSmoothRange(points, smoothSteps);\n      points = smoothRange.points;\n\n      svg.beginPath();\n      svg.strokeStyle = lineStroke;\n      svg.lineWidth = lineWidth;\n      let wasVisible = false;\n      for (let i = 0; i < points.length; i += 2) {\n        let x = points[i];\n        let y = points[i + 1];\n\n        let lastRenderedColumnHeight = columnHeights[x];\n        let isVisible = y <= lastRenderedColumnHeight && y >= 0 && y < trueWindowHeight;\n        if (isVisible) {\n          // This is important bit. We mark the entire area below as \"rendered\"\n          // so that next `isVisible` check will return false, and we will break the line\n          columnHeights[x] = Math.min(y, lastRenderedColumnHeight)\n          // the path is visible:\n          if (wasVisible) {\n            svg.lineTo(x, y);\n          } else {\n            svg.moveTo(x, y);\n          }\n        } else {\n          // The path is no longer visible\n          if (wasVisible) {\n            // But it was visible before\n            svg.lineTo(x, y < 0 ? 0 : lastRenderedColumnHeight);\n          } else {\n            svg.moveTo(x, y < 0? 0 : lastRenderedColumnHeight);\n          }\n        }\n        wasVisible = isVisible;\n      }\n      svg.stroke();\n    }\n\n    /**\n     * Draws filled polyline.\n     */\n    function drawPolyLine(points) {\n      if (points.length < 3) return;\n\n      let smoothRange = getSmoothRange(points, smoothSteps);\n      points = smoothRange.points;\n\n      // If line's height is greater than 2 pixels, let's fill it:\n      if (smoothRange.max - smoothRange.min > 2) {\n        ctx.beginPath();\n        ctx.fillStyle = lineFill;\n        ctx.moveTo(points[0], points[1]);\n        for (let i = 2; i < points.length; i += 2) {\n          ctx.lineTo(points[i], points[i + 1]);\n        }\n        ctx.lineTo(points[points.length - 2], smoothRange.max);\n        ctx.lineTo(points[0], smoothRange.max);\n        ctx.closePath();\n        ctx.fill();\n      }\n\n      ctx.beginPath();\n      ctx.strokeStyle = lineStroke;\n      ctx.lineWidth = lineWidth;\n      ctx.moveTo(points[0], points[1]);\n      for (let i = 2; i < points.length; i += 2) {\n        ctx.lineTo(points[i], points[i + 1]);\n      }\n      ctx.stroke();\n    }\n\n    function clearScene() {\n      ctx.beginPath();\n      ctx.clearRect(0, 0, resWidth, resHeight);\n      ctx.fillStyle = getColor(appState.backgroundColor);\n      ctx.fillRect(0, 0, resWidth, resHeight);\n    }\n  }\n\n  function cancel() {\n    cancelAnimationFrame(renderHandle)\n    appState.renderProgress = null;\n  }\n\n  /**\n   * Simple smoothing function with moving averages, augmented with\n   * min/max calculation (don't want to spend more CPU cycles fo min/max)\n   */\n  function getSmoothRange(points, windowSize) {\n    let result = [];\n    let max = Number.NEGATIVE_INFINITY;\n    let min = Number.POSITIVE_INFINITY;\n    let length = points.length / 2;\n    for (let i = 0; i < length; i += 1) {\n      const leftOffset = i - windowSize;\n      const from = leftOffset >= 0 ? leftOffset : 0\n      const to = i + windowSize + 1;\n\n      let count = 0\n      let sum = 0\n      for (let j = from; j < to && j < length; j += 1) {\n        sum += points[2 * j + 1]\n        count += 1\n      }\n\n      let smoothHeight = sum / count;\n      result[2 * i] = points[2 * i];\n      result[2 * i + 1] = smoothHeight;\n\n      if (max < smoothHeight) max = smoothHeight;\n      if (min > smoothHeight) min = smoothHeight;\n    }\n\n    return {\n      points: result,\n      min,\n      max\n    };\n  }\n\n  /**\n   * Iterate over height map.\n   */\n  function createRegionIterator(rowCount, resHeight, includeRowIndex) {\n    let stepSize = Math.round(resHeight / rowCount);\n    let start = includeRowIndex - Math.floor(includeRowIndex/stepSize) * stepSize;\n    let stop = start + stepSize * Math.floor((resHeight - start) / stepSize)\n\n    return {\n      start,\n      stop,\n      step: stepSize,\n    }\n  }\n\n  function getColor(color, useHex) {\n    if (useHex) {\n      return `#${hex(color.r)}${hex(color.g)}${hex(color.b)}`;\n    }\n    return `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`\n  }\n}\n\nfunction hex(x) {\n  if (x === 0) return '00';\n  let hexValue = x.toString(16)\n  return x < 16 ? '0' + hexValue : hexValue;\n}\n\n\n// WEBPACK FOOTER //\n// ./src/lib/createHeightMapRenderer.js","export const MAPBOX_TOKEN = 'pk.eyJ1IjoiYW52YWthIiwiYSI6ImNrNWRqcDdnNTF4MHYzbXAzNDJzODludnYifQ.2WDAbuAzUuchNtCAcZitAw';\n\n\n\n// WEBPACK FOOTER //\n// ./src/config.js","var inside = require('point-in-polygon');\nvar simplify = require('./simplify');\n\n\nexport default function indexPolygon(nominatimResponse) {\n  return yes;\n  // Work in progress\n  let {boundingbox} = nominatimResponse;\n\n  let tolerance = (boundingbox[3] - boundingbox[2])/1000;\n\n  let checkForGeo = yes;\n\n  if (nominatimResponse.geojson) {\n    checkForGeo = checkInsideGeoJSON(nominatimResponse.geojson);\n  }\n\n  return function isInside(lonLat) {\n    return isInsideBoundingBox(lonLat) && checkForGeo(lonLat);\n  }\n\n  function yes() { return true; }\n\n  function isInsideBoundingBox(lonLat) {\n    return !(lonLat[1] < boundingbox[0] || lonLat[1] > boundingbox[1] ||\n     lonLat[0] < boundingbox[2] || lonLat[0] > boundingbox[3]);\n\n  }\n\n\n  function checkInsideGeoJSON(poly) {\n    let coordinates = poly.coordinates;\n    if (poly.type === 'Polygon') {\n      coordinates = [coordinates];\n    } else if (poly.type === 'MultiPolygon') {\n      coordinates = poly.coordinates;\n    } else if (poly.type === 'Point') {\n      return yes;\n    } else { \n      throw new Error('Unsupported polygon type ' + poly.type);\n    }\n\n    let polygons = coordinates.map(polygon => {\n      let final = simplify(polygon[0], tolerance);\n      console.log('before: ', polygon[0].length, 'After: ', final.length);\n      return final;\n    });\n\n    return function isInsideGeoJSON(lonLat) {\n      for (let i = 0; i < polygons.length; ++i) {\n        if (inside(lonLat, polygons[i])) return true;\n      }\n\n      return false;\n    }\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/indexPolygon.js","import { MAPBOX_TOKEN } from \"./config\";\nimport indexPolygon from \"./lib/indexPolygon\";\n\nconst apiURL = `https://api.mapbox.com/v4/mapbox.terrain-rgb/zoom/tLong/tLat@2x.pngraw?access_token=${MAPBOX_TOKEN}`;\nlet imageCache = new Map();\n\nexport default function getRegionElevation(map, progress, doneCallback) {\n  if (!progress) progress = {};\n\n  const {tileSize, tileZoom} = map.transform;\n  const zoomPower = Math.pow(2, tileZoom);\n\n  const coveringTiles = map.transform.coveringTiles({\n    minzoom: tileZoom,\n    maxzoom: tileZoom,\n    tileSize\n  });\n\n  const tileBounds = getTilesBounds(coveringTiles);\n  const widthInTiles = tileBounds.maxX - tileBounds.minX;\n  const heightInTiles = tileBounds.maxY - tileBounds.minY;\n  if (widthInTiles > 50 || heightInTiles > 50) throw new Error('Too many tiles requested. How did you do it?');\n  let windowHeight = window.innerHeight;\n\n  if (!map.transform.angle && !map.transform.bearing) {\n    // give a little bit of buffer at the bottom if possible\n    let se = map.getBounds().getSouthEast();\n    se.lat = tile2lat(tileBounds.maxY + 1, zoomPower);\n    windowHeight = map.project(se).y;\n  }\n\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = (widthInTiles + 1) * tileSize;\n  canvas.height = (heightInTiles + 1) * tileSize;\n\n  const ctx = canvas.getContext('2d');\n\n  const minX = tileBounds.minX;\n  const minY = tileBounds.minY;\n\n  progress.total = coveringTiles.length;\n\n  advanceProgress();\n\n  let heightsHandle;\n  let isCancelled = false;\n  const tilesToLoad = coveringTiles.map(toLoadedTile);\n\n  Promise.all(tilesToLoad)\n    .then(computeVisibleHeights)\n    .then(createAPI)\n    .then(api => {\n      if (!isCancelled) {\n        doneCallback(api)\n      }\n    });\n\n  return {\n    cancel() {\n      isCancelled = true;\n      cancelAnimationFrame(heightsHandle);\n    }\n  }\n\n  function createAPI(visibleHeights) {\n    let width = visibleHeights.windowWidth;\n    let allHeights = visibleHeights.allHeights;\n\n    return {\n      getHeightAtPoint,\n      windowHeight,\n      getAllHeightData() {\n        return visibleHeights;\n      }\n    };\n\n    function getHeightAtPoint(x, y) {\n      return allHeights[x + y * width];\n    }\n  }\n\n  function computeVisibleHeights() {\n    const canvasWidth = canvas.width;\n    const data = ctx.getImageData(0, 0, canvasWidth, canvas.height).data;\n    const windowWidth = window.innerWidth;\n    let allHeights = new Float32Array(windowWidth * windowHeight);\n    let done;\n\n    let timeQuota = 16;\n    let minHeight = Infinity;\n    let maxHeight = -Infinity;\n    let rowWithHighestPoint = -1;\n    let lastY = 0;\n\n    // // https://nominatim.openstreetmap.org/search.php?q=Canada&polygon_geojson=1&format=json\n    // let geoResponse = require('./lib/fakeResponse.json')[0];\n    let insideMask = indexPolygon(/* geoResponse */);\n    heightsHandle = requestAnimationFrame(collectHeights); // todo let it be cancelled;\n\n    return new Promise((resolve) => { done = resolve });\n\n    function collectHeights() {\n      let startTime = window.performance.now();\n\n      for (let y = lastY; y < windowHeight; ++y) {\n        for (let x = 0; x < windowWidth; ++x) {\n          const index = y * windowWidth + x;\n          const height = getHeight(x, y, insideMask);\n          allHeights[index] = height;\n          if (height < minHeight) minHeight = height;\n          if (height > maxHeight) {\n            maxHeight = height;\n            rowWithHighestPoint = y;\n          }\n        }\n        let elapsed = window.performance.now() - startTime;\n        if (elapsed > timeQuota) {\n          if (!isCancelled) heightsHandle = requestAnimationFrame(collectHeights);\n          return;\n        }\n        lastY = y;\n      }\n\n      done({\n        minHeight, maxHeight, \n        rowWithHighestPoint, \n        allHeights,\n        windowWidth,\n        windowHeight\n      });\n    }\n\n    function getHeight(x, y, insideMask) {\n      let lngLat = map.transform.pointLocation({x, y})\n      if (!insideMask([lngLat.lng, lngLat.lat])) return -20;\n\n      let xTile = lng2tile(lngLat.lng, zoomPower);\n      let xOffset = (xTile - minX) * tileSize;\n      let yTile = lat2tile(lngLat.lat, zoomPower);\n      let yOffset = (yTile - minY) * tileSize;\n      let yC = Math.round(yOffset);\n      let xC = Math.round(xOffset);\n\n      let index = (yC * canvasWidth + xC) * 4;\n      let R = data[index + 0];\n      let G = data[index + 1];\n      let B = data[index + 2];\n\n      return decodeHeight(R, G, B)\n    }\n\n    function decodeHeight(R, G, B) {\n      let height = -10000 + ((R * 256 * 256 + G * 256 + B) * 0.1)\n      if (height < -100) {\n        // Fiji islands data has huge caves, which pushes the entire thing up.\n        // I'm reducing it.\n        height = height / 5000;\n      }\n      return height;\n    }\n  }\n\n  function toLoadedTile(tile) {\n    const request = getRequestForTile(tile);\n\n    return loadImage(request.url)\n      .then(drawTileImage)\n      .catch(drawBlankTile)\n      .finally(advanceProgress);\n\n    function drawTileImage(image) {\n      ctx.drawImage(image, request.x, request.y);\n    }\n\n    function drawBlankTile() {\n      ctx.beginPath();\n      ctx.fillStyle = '#0186a0'; // zero height\n      ctx.fillRect(request.x, request.y, tileSize, tileSize);\n    }\n  }\n\n  function getRequestForTile(tile) {\n    const p = tile.canonical;\n    const url = apiURL\n      .replace('zoom', p.z)\n      .replace('tLat', p.y)\n      .replace('tLong', p.x);\n\n    return {\n      url,\n      x: tileSize * (p.x - tileBounds.minX), \n      y: tileSize * (p.y - tileBounds.minY)\n    }\n  }\n\n  function advanceProgress() {\n    if (progress.completed === undefined) {\n      progress.completed = -1;\n    }\n    progress.completed = Math.min(progress.total, progress.completed + 1);\n    progress.message = `Downloading tiles: ${progress.completed} of ${progress.total}...`\n  }\n  \n}\n\nfunction lng2tile(l, zoomPower) {\n  let result = ((l + 180) / 360) * zoomPower;\n  return result;\n}\n\nfunction lat2tile(l, zoomPower) {\n  let angle = l * Math.PI / 180;\n  return (\n    ((1 - Math.log( Math.tan(angle) + 1 / Math.cos(angle)) /\n        Math.PI) /\n      2) * zoomPower \n  );\n}\n\nfunction tile2lat(y, zoomPower) {\n  let n = Math.PI - 2 * Math.PI * y / zoomPower;\n  return 180 / Math.PI * Math.atan(0.5*(Math.exp(n)-Math.exp(-n)));\n}\n\nfunction loadImage(url) {\n  let cachedImage = imageCache.get(url);\n  if (!cachedImage) {\n    cachedImage = new Promise((resolve, error) => {\n      const img = new Image();\n      img.onload = () => {\n        resolve(img);\n      };\n      img.onerror = error;\n      img.crossOrigin = \"anonymous\";\n      img.src = url;\n    });\n    imageCache.set(url, cachedImage);\n  }\n\n  return cachedImage;\n}\n\nfunction getTilesBounds(tiles) {\n  return tiles.reduce((bounds, tile) => {\n    let p = tile.canonical;\n    if (bounds.minX > p.x) bounds.minX = p.x;\n    if (bounds.minY > p.y) bounds.minY = p.y;\n    if (bounds.maxX < p.x) bounds.maxX = p.x;\n    if (bounds.maxY < p.y) bounds.maxY = p.y;\n\n    return bounds;\n  }, {\n    minX: Infinity,\n    minY: Infinity,\n    maxX: -Infinity,\n    maxY: -Infinity\n  })\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/getRegionElevation.js","/**\n * This is the website startup point.\n */\nimport appState from \"./appState\";\nimport mapboxgl from \"mapbox-gl\";\nimport createHeightMapRenderer from \"./lib/createHeightMapRenderer\";\nimport { MAPBOX_TOKEN } from \"./config\";\nimport getRegionElevation from './getRegionElevation';\n\nvar MapboxGeocoder = require(\"@mapbox/mapbox-gl-geocoder\");\nwindow.addEventListener('error', logError);\n\n// Load vue asyncronously\nrequire.ensure(\"@/vueApp.js\", () => {\n  require(\"@/vueApp.js\");\n});\n\n// Hold a reference to mapboxgl instance.\nlet map;\nlet heightMapRenderer;\nlet regionBuilder;\n// Let the vue know what to call to start the app.\nappState.init = init;\nappState.redraw = redraw;\nappState.updateMap = updateMap;\nappState.exportToSVG = exportToSVG;\n\nfunction init() {\n  mapboxgl.accessToken = MAPBOX_TOKEN;\n\n  window.map = map = new mapboxgl.Map({\n    trackResize: true,\n    container: \"map\",\n    minZoom: 0,\n    style: \"mapbox://styles/mapbox/light-v10\",\n    center: [-122.574, 47.727],\n    zoom: 7.68,\n    hash: true\n  });\n\n  map.addControl(\n    new mapboxgl.NavigationControl({ showCompass: false }),\n    \"bottom-right\"\n  );\n  map.addControl(new MapboxGeocoder({ accessToken: mapboxgl.accessToken }));\n  map.on('moveend', function() {\n    map.once('idle', updateMap)\n  });\n  map.on(\"movestart\", hideHeights);\n  map.on(\"load\", function() {\n    appState.angle = map.getBearing();\n    // map.showTileBoundaries = true;\n  });\n\n  map.dragRotate.disable();\n  map.touchZoomRotate.disableRotation();\n}\n\nfunction hideHeights() {\n  appState.zazzleLink = null;\n  let canvas = document.querySelector(\".height-map\");\n  if (canvas) canvas.style.opacity = 0.02;\n}\n\nfunction redraw() {\n  if (!heightMapRenderer) return;\n  heightMapRenderer.cancel();\n  heightMapRenderer.render();\n}\n\nfunction exportToSVG() {\n  if (!heightMapRenderer) return;\n  return heightMapRenderer.render(true);\n}\n\nfunction updateMap() {\n  if (!map) return;\n\n  let heightMapCanvas = document.querySelector(\".height-map\");\n  if (!heightMapCanvas) return;\n\n  if (heightMapRenderer) {\n    heightMapRenderer.cancel();\n  }\n  if (regionBuilder) {\n    regionBuilder.cancel();\n  }\n\n  if (!appState.shouldDraw) {\n    heightMapCanvas.style.display = \"none\";\n    return;\n  } else {\n    heightMapCanvas.style.display = \"\";\n  }\n  \n  appState.renderProgress = {\n    message: '',\n    isCancelled: false,\n    completed: false\n  };\n\n  // This will fetch all heightmap tiles\n  regionBuilder = getRegionElevation(map, appState.renderProgress, showRegionHeights)\n\n  function showRegionHeights(regionInfo) {\n    heightMapRenderer = createHeightMapRenderer(appState, regionInfo, heightMapCanvas);\n  }\n}\n\n\nfunction logError(e) {\n  if (typeof ga !== 'function') return;\n\n  const exDescription = e ? `${e.message} in ${e.filename}:${e.lineno}` : 'Unknown exception';\n\n  ga('send', 'exception', {\n    exDescription,\n    exFatal: false\n  });\n}\n\n\n// WEBPACK FOOTER //\n// ./src/main.js"],"sourceRoot":""}